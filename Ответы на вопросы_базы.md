
---

### **26. Что подразумевается под СУБД?**
**СУБД** (Система Управления Базами Данных, Database Management System) — это программное обеспечение, которое позволяет создавать, управлять и обрабатывать базы данных. Она предоставляет интерфейс для выполнения операций с данными, таких как добавление, изменение, удаление и поиск.

Примеры СУБД:
- MySQL
- PostgreSQL
- Oracle
- SQLite
- Microsoft SQL Server

---

### **27. Что такое соединения в SQL?**
**Соединения (Joins)** в SQL — это механизм для объединения данных из двух или более таблиц на основе связанных между ними столбцов. Соединения позволяют извлекать данные, которые распределены по разным таблицам, в одном запросе.

---

### **28. Какие типы соединений вы знаете?**
Основные типы соединений в SQL:
1. **INNER JOIN** — возвращает только те строки, где есть совпадение в обеих таблицах.
2. **LEFT JOIN (или LEFT OUTER JOIN)** — возвращает все строки из левой таблицы и совпадающие строки из правой таблицы. Если совпадений нет, возвращаются NULL.
3. **RIGHT JOIN (или RIGHT OUTER JOIN)** — возвращает все строки из правой таблицы и совпадающие строки из левой таблицы. Если совпадений нет, возвращаются NULL.
4. **FULL JOIN (или FULL OUTER JOIN)** — возвращает все строки из обеих таблиц, даже если совпадений нет.
5. **CROSS JOIN** — возвращает декартово произведение двух таблиц (каждая строка из первой таблицы соединяется с каждой строкой из второй таблицы).

---

### **29. Что такое индекс?**
**Индекс** — это структура данных, которая ускоряет поиск и извлечение данных из таблицы. Он похож на указатель в книге: он помогает быстро находить нужные данные, не просматривая всю таблицу.

Пример:
- Если у вас есть таблица с миллионами строк, индекс позволяет быстро находить нужные записи.

---

### **30. В чем разница между кластеризованным и некластеризованным индексами в SQL?**
1. **Кластеризованный индекс (Clustered Index):**
   - Определяет физический порядок данных в таблице.
   - Таблица может иметь только один кластеризованный индекс.
   - Данные физически хранятся в порядке, соответствующем кластеризованному индексу.

2. **Некластеризованный индекс (Non-Clustered Index):**
   - Не изменяет физический порядок данных.
   - Создает отдельную структуру, которая указывает на физическое расположение данных.
   - Таблица может иметь несколько некластеризованных индексов.

---

### **31. Что вы подразумеваете под денормализацией?**
**Денормализация** — это процесс намеренного добавления избыточности в базу данных для улучшения производительности запросов. В отличие от нормализации, которая минимизирует избыточность, денормализация позволяет уменьшить количество соединений и ускорить выполнение запросов.

Пример:
- Если в нормализованной базе данных нужно часто объединять таблицы, можно добавить дублирующие данные в одну из таблиц для ускорения доступа.

---

### **32. Что такое свойство ACID в базе данных?**
**ACID** — это набор свойств, которые обеспечивают надежность транзакций в базе данных:
1. **Atomicity (Атомарность):** Транзакция выполняется полностью или не выполняется вообще (нет частичного выполнения).
2. **Consistency (Согласованность):** Транзакция переводит базу данных из одного корректного состояния в другое.
3. **Isolation (Изолированность):** Одновременные транзакции не влияют друг на друга.
4. **Durability (Долговечность):** После завершения транзакции её результаты сохраняются даже в случае сбоя системы.

---

### **33. Что такое подзапрос в SQL?**
**Подзапрос (Subquery)** — это запрос, который вложен внутрь другого запроса. Он используется для получения данных, которые будут использоваться в основном запросе.

Пример:
```sql
SELECT name FROM employees 
WHERE department_id = (SELECT id FROM departments WHERE name = 'IT');
```

---

### **34. Какие бывают типы подзапросов?**
1. **Коррелированные подзапросы:** Подзапрос зависит от внешнего запроса.
2. **Некоррелированные подзапросы:** Подзапрос выполняется независимо от внешнего запроса.
3. **Скалярные подзапросы:** Возвращают одно значение.
4. **Многострочные подзапросы:** Возвращают несколько строк.

---

### **35. Какие существуют способы оптимизации запроса?**
1. **Создание индексов:** Ускоряет поиск данных.
2. **Уменьшение количества соединений:** Использование денормализации или объединение таблиц.
3. **Использование EXPLAIN:** Анализ плана выполнения запроса.
4. **Оптимизация WHERE:** Уменьшение количества строк для фильтрации.
5. **Кэширование результатов:** Хранение часто используемых данных в памяти.

---

### **36. Назовите оператор, который используется в запросе на сопоставление с образцом.**
Оператор для сопоставления с образцом в SQL — это **LIKE**.

Пример:
```sql
SELECT * FROM employees WHERE name LIKE 'J%';
```

---

### **37. Что такое DDL и DML?**
1. **DDL (Data Definition Language):**
   - Язык определения данных.
   - Команды для создания, изменения и удаления структур базы данных (таблиц, индексов и т.д.).
   - Примеры команд: `CREATE`, `ALTER`, `DROP`.

2. **DML (Data Manipulation Language):**
   - Язык манипулирования данными.
   - Команды для работы с данными в таблицах.
   - Примеры команд: `SELECT`, `INSERT`, `UPDATE`, `DELETE`.

---

### **38. Какие агрегатные функции вы знаете?**
1. **COUNT()** — подсчитывает количество строк.
2. **SUM()** — вычисляет сумму значений.
3. **AVG()** — вычисляет среднее значение.
4. **MIN()** — возвращает минимальное значение.
5. **MAX()** — возвращает максимальное значение.

Пример:
```sql
SELECT AVG(salary) FROM employees;
```

---

### **39. Какие команды управления транзакциями вы знаете?**
1. **BEGIN TRANSACTION (или START TRANSACTION):** Начинает транзакцию.
2. **COMMIT:** Фиксирует транзакцию (сохраняет изменения).
3. **ROLLBACK:** Откатывает транзакцию (отменяет изменения).
4. **SAVEPOINT:** Создает точку сохранения внутри транзакции.

Пример:
```sql
BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
COMMIT;
```

---

### **40. Что такое уровни изолированности транзакций?**
**Уровни изолированности транзакций** определяют, как одновременные транзакции влияют друг на друга. Основные уровни:
1. **Read Uncommitted:** Транзакции видят незафиксированные изменения других транзакций (возможны "грязные" чтения).
2. **Read Committed:** Транзакции видят только зафиксированные изменения других транзакций.
3. **Repeatable Read:** Гарантирует, что данные, прочитанные один раз, остаются неизменными в течение транзакции.
4. **Serializable:** Наивысший уровень изоляции, предотвращает все виды конфликтов.
Вот ответы на ваши вопросы:

---

### **40. Что такое уровни изолированности транзакций?**
**Уровни изолированности транзакций** определяют, как одновременные транзакции влияют друг на друга. Они определяют, какие виды конфликтов разрешены или запрещены. Основные уровни:

1. **Read Uncommitted (Чтение незафиксированных данных):**
   - Транзакции видят незафиксированные изменения других транзакций (возможны "грязные" чтения).

2. **Read Committed (Чтение зафиксированных данных):**
   - Транзакции видят только зафиксированные изменения других транзакций.

3. **Repeatable Read (Повторяемое чтение):**
   - Гарантирует, что данные, прочитанные один раз, остаются неизменными в течение транзакции.

4. **Serializable (Последовательное выполнение):**
   - Наивысший уровень изоляции, предотвращает все виды конфликтов (например, фантомные чтения).

Пример установки уровня изоляции в PostgreSQL:
```sql
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

---

### **41. Что такое вложенные транзакции?**
**Вложенные транзакции** — это транзакции, которые выполняются внутри другой транзакции. Они позволяют выполнять частичные операции, которые могут быть зафиксированы или откачены независимо от внешней транзакции.

Пример в PostgreSQL:
```sql
BEGIN;
SAVEPOINT my_savepoint;
-- Выполнение операций
ROLLBACK TO my_savepoint; -- Откат до точки сохранения
COMMIT;
```

---

### **42. Что такое курсор и зачем он нужен?**
**Курсор** — это объект, который позволяет обрабатывать результаты запроса по одной строке за раз. Он полезен, когда нужно работать с большими объемами данных, которые не помещаются в память.

Пример использования курсора в SQL:
```sql
DECLARE my_cursor CURSOR FOR SELECT * FROM employees;
FETCH NEXT FROM my_cursor;
```

---

### **43. Какая разница между PostgreSQL и MySQL?**
| **Характеристика**       | **PostgreSQL**                          | **MySQL**                              |
|--------------------------|-----------------------------------------|----------------------------------------|
| **Тип СУБД**             | Объектно-реляционная СУБД               | Реляционная СУБД                      |
| **Функциональность**     | Более расширенные возможности (JSON, GIS) | Проще и быстрее для небольших проектов |
| **Скорость**             | Медленнее на простых запросах            | Быстрее на простых запросах            |
| **Поддержка SQL**        | Строго следует стандартам SQL            | Имеет свои расширения и отклонения      |
| **Отказоустойчивость**    | Лучше поддержка репликации и кластеров   | Поддержка репликации, но проще         |
| **Лицензия**             | PostgreSQL License (open source)        | GPL (open source)                      |

---

### **44. Что такое VACUUM в PostgreSQL?**
**VACUUM** — это команда в PostgreSQL, которая освобождает место, занятое "мертвыми" кортежами (удаленными или обновленными строками). Она также обновляет статистику для оптимизатора запросов.

Пример:
```sql
VACUUM;
```

---

### **45. Что такое EXPLAIN?**
**EXPLAIN** — это команда в SQL, которая показывает план выполнения запроса. Она помогает понять, как СУБД будет выполнять запрос, и выявить возможные узкие места.

Пример:
```sql
EXPLAIN SELECT * FROM employees WHERE age > 30;
```

---

### **46. Какая разница между EXPLAIN и EXPLAIN ANALYZE?**
1. **EXPLAIN:**
   - Показывает план выполнения запроса, но не выполняет сам запрос.
   - Используется для оценки производительности.

2. **EXPLAIN ANALYZE:**
   - Выполняет запрос и показывает реальный план выполнения.
   - Показывает время выполнения каждого шага и количество строк, обработанных на каждом этапе.

Пример:
```sql
EXPLAIN ANALYZE SELECT * FROM employees WHERE age > 30;
```

---

### **47. Для чего нужна Metadata в SQLAlchemy?**
**Metadata** в SQLAlchemy — это объект, который содержит информацию о структуре базы данных (таблицы, столбцы, индексы и т.д.). Он используется для создания, изменения и удаления таблиц и других объектов базы данных.

Пример:
```python
from sqlalchemy import MetaData, Table, Column, Integer, String

metadata = MetaData()

users_table = Table(
    'users', metadata,
    Column('id', Integer, primary_key=True),
    Column('name', String)
)

metadata.create_all(engine)  # Создание таблицы
```

---

### **48. В чем разница между selectinload и joinedload?**
1. **joinedload:**
   - Загружает связанные объекты с помощью `JOIN`.
   - Подходит для загрузки небольшого количества связанных объектов.

2. **selectinload:**
   - Загружает связанные объекты с помощью отдельного запроса.
   - Подходит для загрузки большого количества связанных объектов, так как позволяет избежать больших `JOIN`.

Пример:
```python
from sqlalchemy.orm import joinedload, selectinload

# joinedload
session.query(User).options(joinedload(User.posts)).all()

# selectinload
session.query(User).options(selectinload(User.posts)).all()
```

---

### **49. Как избежать SQL-инъекций?**
1. **Использование параметризованных запросов:**
   - Передавать данные в запрос через параметры, а не через конкатенацию строк.

Пример:
```python
query = "SELECT * FROM users WHERE username = :username"
result = session.execute(query, {"username": user_input})
```

2. **ORM (например, SQLAlchemy):**
   - Использовать ORM, которые автоматически экранируют данные.

3. **Проверка входных данных:**
   - Валидировать и очищать входные данные перед использованием в запросах.

---

### **50. В чем разница между подключением и сессией?**
1. **Подключение (Connection):**
   - Физическое соединение с базой данных.
   - Используется для выполнения SQL-запросов.

2. **Сессия (Session):**
   - Объект высокого уровня, который управляет жизненным циклом объектов (добавление, изменение, удаление).
   - Использует подключение для выполнения операций.

Пример:
```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

engine = create_engine('sqlite:///example.db')
Session = sessionmaker(bind=engine)
session = Session()

# Использование сессии
session.add(User(name="Alice"))
session.commit()
```

---

