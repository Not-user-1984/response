## Зачем нам нужен asyncio?
    Для асинхронного выполнения задач, чтобы эффективно работать с I/O-операциями (сеть, файлы и т.д.) без блокировки основного потока.

## с I/O-операции что такое?
I/O-операции (Input/Output) — это операции ввода-вывода, например: чтение/запись файлов, запросы к базам данных, сетевые запросы. Они часто занимают время, и asyncio позволяет не блокировать выполнение программы, пока ждёте их завершения.

## Что такое асинхронный код?
Асинхронный код — это код, который может выполнять задачи по частям, переключаясь между ними, пока одна из них ожидает (например, ответа от сервера). Это позволяет эффективно использовать ресурсы и не блокировать выполнение программы.
    
## Что такое GIL? Как он устроен?
GIL (Global Interpreter Lock) — это мьютекс в Python, который позволяет выполнять только один поток Python одновременно, даже на многоядерных процессорах. Он нужен для защиты памяти интерпретатора, но ограничивает параллелизм в CPU-задачах. GIL не мешает в I/O-операциях, где работает asyncio.



## Что происходит при обращении к генератору функциями send, next, throw?
1. **`next()`**: Запускает или возобновляет выполнение генератора до следующего `yield`. Возвращает значение после `yield`.  
2. **`send()`**: Передаёт значение в генератор, которое становится результатом `yield`, и продолжает выполнение до следующего `yield`.  
3. **`throw()`**: Генерирует исключение внутри генератора на текущем `yield`.  

Примеры использования генераторов с `next`, `send` и `throw`:

`next()`
```python
def simple_gen():
    yield 1
    yield 2
    yield 3

gen = simple_gen()
print(next(gen))  # 1
print(next(gen))  # 2
print(next(gen))  # 3
```

`send()`
```python
def gen_with_send():
    value = yield "Start"
    yield f"Received: {value}"

gen = gen_with_send()
print(next(gen))  # "Start" (доходит до первого yield)
print(gen.send("Hello"))  # "Received: Hello" (передаёт "Hello" в yield)
```

`throw()`
```python
def gen_with_throw():
    try:
        yield "Ready"
    except ValueError as e:
        yield f"Caught: {e}"

gen = gen_with_throw()
print(next(gen))  # "Ready"
print(gen.throw(ValueError("Oops!")))  # "Caught: Oops!" (генератор ловит исключение)
```





## как GIL участвует при выполнении асинхронного python кода?

GIL (Global Interpreter Lock) в асинхронном коде Python **не блокирует выполнение**, так как асинхронные задачи работают в одном потоке, переключаясь между собой через event loop. GIL мешает только при параллельном выполнении CPU-задач в нескольких потоках, но асинхронный код в основном работает с I/O-операциями (сеть, файлы), где GIL не является проблемой. 

Таким образом, **GIL не влияет на производительность асинхронного кода**, если он не выполняет CPU-интенсивные задачи.


## Основные понятия `asyncio`

Основные понятия `asyncio`:

1. **Event Loop** — ядро asyncio, управляет выполнением асинхронных задач.
2. **Coroutine** — асинхронная функция, определяется через `async def`.
3. **Task** — обёртка вокруг корутины, планируемая на выполнение в event loop.
4. **Future** — объект, представляющий результат асинхронной операции (обычно используется внутри Task).
5. **Await** — ключевое слово для приостановки корутины до завершения другой асинхронной операции.
6. **Async/Await** — синтаксис для работы с асинхронным кодом.
7. **Queue** — асинхронная очередь для обмена данными между задачами.
8. **Semaphore/Lock** — примитивы для синхронизации асинхронных задач.


## **Event Loop** 
**Event Loop** — это ядро асинхронного программирования в `asyncio`. Он управляет выполнением асинхронных задач, распределяет время между ними и обрабатывает события (например, завершение I/O-операций). Event Loop работает в одном потоке, переключаясь между задачами, чтобы эффективно использовать ресурсы.

### Основные функции:

1. Запуск и остановка корутин.
    
2. Обработка асинхронных операций (сеть, таймеры, файлы).
    
3. Планирование задач (Task) и их выполнение.


## **Coroutine (корутина)**

**Coroutine (корутина)** — это специальная функция в Python, определённая с помощью `async def`. Она может приостанавливать своё выполнение на операциях `await` и возобновлять его позже. Корутины используются для написания асинхронного кода.

1. Вызывается с `await`.
    
2. Не выполняется сразу при вызове — возвращает объект корутины, который нужно запустить через event loop.
    
3. Позволяет писать асинхронный код, который выглядит как синхронный.



# Task (задача)
**Task (задача)** — это объект в `asyncio`, который представляет запущенную корутину, планируемую на выполнение в event loop. Task используется для управления и отслеживания состояния асинхронной операции.

Особенности:
1. Создаётся с помощью `asyncio.create_task()` или `loop.create_task()`.
2. Позволяет выполнять корутины конкурентно.
3. Можно отменять с помощью `task.cancel()`.
4. Позволяет отслеживать завершение с помощью `await task`.
   
## Future
**Future** — это объект, представляющий результат асинхронной операции, который может быть ещё не готов. Используется для отслеживания состояния и получения результата позже. Основа для `Task` в `asyncio`.


# await

**`await`** — ключевое слово в Python для приостановки выполнения корутины до завершения асинхронной операции (например, другой корутины, `Future` или `Task`). Используется только внутри асинхронных функций (`async def`).

Пример:
```python
import asyncio

async def my_task():
    await asyncio.sleep(1)  # Приостановка на 1 секунду
    return "Done!"

async def main():
    result = await my_task()  # Ожидание завершения my_task
    print(result)

asyncio.run(main())
```

**Вывод:**
```
Done!
```

# Queue

**`Queue`** в `asyncio` — это асинхронная очередь для обмена данными между корутинами. Она позволяет безопасно добавлять и извлекать элементы в асинхронном режиме.
 Основные методы:
1. **`put(item)`**: Добавляет элемент в очередь. Если очередь заполнена, ждёт свободного места.
2. **`get()`**: Извлекает элемент из очереди. Если очередь пуста, ждёт появления элемента.
3. **`join()`**: Ожидает, пока очередь не станет пустой.
4. **`task_done()`**: Сигнализирует, что элемент обработан.

### Пример:
```python
import asyncio

async def producer(queue):
    for i in range(5):
        print(f"Producing {i}")
        await queue.put(i)  # Добавляем элемент
        await asyncio.sleep(0.5)

async def consumer(queue):
    while True:
        item = await queue.get()  # Извлекаем элемент
        print(f"Consuming {item}")
        queue.task_done()  # Сигнализируем, что элемент обработан

async def main():
    queue = asyncio.Queue()
    producer_task = asyncio.create_task(producer(queue))
    consumer_task = asyncio.create_task(consumer(queue))

    await producer_task  # Ждём завершения producer
    await queue.join()   # Ждём обработки всех элементов
    consumer_task.cancel()  # Останавливаем consumer

asyncio.run(main())
Producing 0
Consuming 0
Producing 1
Consuming 1
Producing 2
Consuming 2
Producing 3
Consuming 3
Producing 4
Consuming 4
```

`Queue` удобна для организации асинхронного взаимодействия между задачами.

Основные недостатки `asyncio.Queue`:

1. **Ограничение размера**: Если очередь заполнена, `put()` будет ждать, пока не освободится место, что может привести к блокировке.
2. **Сложность отладки**: Асинхронные взаимодействия через очередь могут усложнить отладку и понимание потока данных.
3. **Риск deadlock**: Неправильное использование `join()` и `task_done()` может привести к зависанию программы.
4. **Производительность**: Для высоконагруженных систем может быть недостаточно эффективной из-за накладных расходов на синхронизацию.
5. **Однопоточность**: В рамках одного event loop, что ограничивает масштабируемость на многопроцессорных системах.

Эти недостатки важно учитывать при проектировании асинхронных систем.


# Semaphore/Lock

**`Semaphore`** и **`Lock`** в `asyncio` — это примитивы для синхронизации асинхронных задач.

 1. **`Lock`**:
   - Используется для обеспечения эксклюзивного доступа к ресурсу.
   - Только одна корутина может захватить блокировку одновременно.

### Пример:
```python
import asyncio

async def worker(lock, name):
    async with lock:  # Захват блокировки
        print(f"{name} started")
        await asyncio.sleep(1)
        print(f"{name} finished")

async def main():
    lock = asyncio.Lock()
    await asyncio.gather(worker(lock, "Task 1"), worker(lock, "Task 2"))

asyncio.run(main())
```

**Вывод:**
```
Task 1 started
Task 1 finished
Task 2 started
Task 2 finished
```

 2. **`Semaphore`**:
   - Ограничивает количество корутин, которые могут одновременно выполнять определённый участок кода.
   - Полезен для ограничения параллелизма (например, количество одновременных запросов).

### Пример:
```python
import asyncio

async def worker(sem, name):
    async with sem:  # Захват семафора
        print(f"{name} started")
        await asyncio.sleep(1)
        print(f"{name} finished")

async def main():
    sem = asyncio.Semaphore(2)  # Максимум 2 задачи одновременно
    await asyncio.gather(worker(sem, "Task 1"), worker(sem, "Task 2"), worker(sem, "Task 3"))

asyncio.run(main())
```

**Вывод:**
```
Task 1 started
Task 2 started
Task 1 finished
Task 2 finished
Task 3 started
Task 3 finished
```

### Основные различия:
- **`Lock`**: Эксклюзивный доступ (только одна задача).
- **`Semaphore`**: Ограниченный доступ (N задач одновременно).






## Основные отличия **`threading`** и **`asyncio`**:


Основные отличия **`threading`** и **`asyncio`**:

 1. **Модель выполнения:**
   - **`threading`**: Использует потоки (threads), которые выполняются параллельно (если GIL позволяет). Подходит для CPU-задач и I/O-операций, но требует осторожности с синхронизацией.
   - **`asyncio`**: Работает в одном потоке, переключаясь между задачами (корутинами) через event loop. Оптимален для I/O-задач (сеть, файлы), но не для CPU-интенсивных операций.

 2. **Параллелизм:**
   - **`threading`**: Реальное параллельное выполнение (на многопроцессорных системах), но с ограничениями из-за GIL.
   - **`asyncio`**: Однопоточный, но с эффективным переключением между задачами. Нет проблем с GIL, но нет реального параллелизма.

 3. **Сложность:**
   - **`threading`**: Требует управления блокировками (locks, semaphores) для избежания race conditions.
   - **`asyncio`**: Проще в использовании, так как задачи выполняются в одном потоке и не требуют синхронизации.

4. **Производительность:**
   - **`threading`**: Может быть затратным из-за создания потоков и переключения между ними.
   - **`asyncio`**: Легковесный, так как корутины дешевле потоков.

 Когда использовать:
- **`threading`**: Для CPU-интенсивных задач или когда нужно реальное параллельное выполнение.
- **`asyncio`**: Для I/O-задач (сеть, базы данных, файлы), где важно эффективное использование ресурсов.

### Пример:
```python
# threading
import threading

def task():
    print("Threading task")

thread = threading.Thread(target=task)
thread.start()
thread.join()

# asyncio
import asyncio

async def task():
    print("Asyncio task")

asyncio.run(task())
```

# Основные отличия **`gather()`** и **`create_task()`**:

Основные отличия **`gather()`** и **`create_task()`**:

1. **`gather()`**:
   - Запускает несколько задач одновременно и ждёт завершения **всех**.
   - Возвращает **список результатов**.
   - Удобен для параллельного выполнения и сбора результатов.

2. **`create_task()`**:
   - Создаёт **одну задачу** и сразу возвращает её объект (`Task`).
   - Не ждёт завершения задачи.
   - Удобен для фоновых задач или ручного управления.

### Пример:
```python
import asyncio

async def task(n):
    await asyncio.sleep(n)
    return f"Task {n} done"

async def main():
    # create_task
    task1 = asyncio.create_task(task(1))
    task2 = asyncio.create_task(task(2))
    await task1  # Ждём завершения вручную
    await task2

    # gather
    results = await asyncio.gather(task(1), task(2))
    print(results)

asyncio.run(main())
```

**Итог:**
- Используйте **`gather()`** для параллельного выполнения и сбора результатов.
- Используйте **`create_task()`** для ручного управления задачами.

## как использовать TaskGroup()
**`TaskGroup()`** (доступен с Python 3.11) — это более удобный и безопасный способ управления группой задач по сравнению с `gather()`. Он автоматически отменяет все задачи, если одна из них завершилась с ошибкой.

### Основные особенности:
1. **Автоматическая отмена**: Если одна задача завершается с ошибкой, остальные задачи автоматически отменяются.
2. **Контекстный менеджер**: Используется с `async with`.
3. **Удобство**: Проще управлять задачами, чем с `gather()`.

### Пример использования:
```python
import asyncio

async def task(n):
    await asyncio.sleep(n)
    if n == 2:
        raise ValueError("Error in task 2")
    return f"Task {n} done"

async def main():
    try:
        async with asyncio.TaskGroup() as tg:  # Создаём группу задач
            task1 = tg.create_task(task(1))
            task2 = tg.create_task(task(2))
            task3 = tg.create_task(task(3))
        print("All tasks completed successfully")
    except Exception as e:
        print(f"Error: {e}")

asyncio.run(main())
```

**Вывод:**
```
Error: Error in task 2
```

### Как это работает:
1. Задачи создаются через `tg.create_task()` внутри контекстного менеджера `async with`.
2. Если одна задача завершается с ошибкой, все остальные задачи автоматически отменяются.
3. Исключение из задачи пробрасывается наружу, где его можно обработать.

### Преимущества перед `gather()`:
- Более безопасное управление задачами.
- Автоматическая отмена при ошибках.
- Удобный синтаксис.

Используйте `TaskGroup()` для управления группами задач, особенно когда важна отмена всех задач при ошибке.


# asyncio.to_thread() или loop.run_in_executor()

Для запуска блокирующего кода в асинхронном приложении используйте **`asyncio.to_thread()`** или **`loop.run_in_executor()`**. Они выполняют блокирующий код в отдельном потоке, не блокируя event loop.

---

### 1. **`asyncio.to_thread()`** (Python 3.9+)
Запускает блокирующую функцию в отдельном потоке.

```python
import asyncio
import time

def blocking_task():
    time.sleep(2)  # Блокирующий код
    return "Done"

async def main():
    result = await asyncio.to_thread(blocking_task)  # Запуск в потоке
    print(result)

asyncio.run(main())
```

**Вывод:**
```
Done
```

---

### 2. **`loop.run_in_executor()`**
Запускает блокирующую функцию в пуле потоков (по умолчанию используется `ThreadPoolExecutor`).

```python
import asyncio
import time

def blocking_task():
    time.sleep(2)  # Блокирующий код
    return "Done"

async def main():
    loop = asyncio.get_event_loop()
    result = await loop.run_in_executor(None, blocking_task)  # Запуск в потоке
    print(result)

asyncio.run(main())
```

**Вывод:**
```
Done
```

---

### 3. **Использование `ThreadPoolExecutor` напрямую**
Если нужно больше контроля, можно использовать `concurrent.futures.ThreadPoolExecutor`.

```python
import asyncio
from concurrent.futures import ThreadPoolExecutor
import time

def blocking_task():
    time.sleep(2)  # Блокирующий код
    return "Done"

async def main():
    with ThreadPoolExecutor() as pool:
        result = await asyncio.get_event_loop().run_in_executor(pool, blocking_task)
        print(result)

asyncio.run(main())
```

**Вывод:**
```
Done
```

---

### Итог:
- Используйте **`asyncio.to_thread()`** для простых случаев.
- Используйте **`loop.run_in_executor()`** для более гибкого управления.
- Используйте **`ThreadPoolExecutor`**, если нужен контроль над пулом потоков.

Эти методы позволяют интегрировать блокирующий код в асинхронное приложение без блокировки event loop.


# многопоточность в одном процессе и асихрхроность? когда что применять?

| **Критерий**            | **Асинхронность**                  | **Многопоточность в одном процессе** |
|--------------------------|------------------------------------|--------------------------------------|
| **Тип задач**            | I/O-задачи (сеть, файлы, БД)      | Блокирующий код, сложные задачи      |
| **Параллелизм**          | Однопоточный (кооперативная многозадачность) | Реальный параллелизм (много потоков) |
| **Ресурсы**              | Легковесный (меньше памяти)       | Тяжелее (потоки потребляют больше памяти) |
| **Сложность**            | Проще для I/O-задач               | Требует синхронизации (Lock, Semaphore) |
| **Производительность**   | Высокая для I/O-задач             | Высокая для блокирующих задач        |
