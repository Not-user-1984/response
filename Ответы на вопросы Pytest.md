# Какой командой запускается Pytest?

Командой `pytest` в терминале из корня проекта.

---

# Какой файл используется для настройки поведения Pytest?
Файл `pytest.ini` используется для настройки поведения Pytest (например, маркеров, параметров запуска).




---

# Какой декоратор используется для пропуска теста?

Декоратор `@pytest.mark.skip` используется для пропуска теста. Если нужно пропустить при условии, используется `@pytest.mark.skipif`.

---

# Как выполнить тесты в параллельном режиме с Pytest?

Установите плагин `pytest-xdist` и используйте флаг `-n` с указанием количества потоков, например:  
```bash
pytest -n 4
```  
Это запустит тесты в 4 потока.

---

# Как можно пометить тест, чтобы его запускали с определенным маркером?

Используйте декоратор `@pytest.mark.<имя_маркера>`. Например:  
```python
@pytest.mark.smoke
def test_example():
    assert True
```  
Затем запустите тесты с этим маркером:  
```bash
pytest -m smoke
```

---

# Какой командой можно увидеть список всех доступных маркеров?

Команда:  
```bash
pytest --markers
```  
Покажет список всех доступных маркеров, включая кастомные, определённые в `pytest.ini` или `conftest.py`.

---

# Как можно запустить только тесты с определенным маркером?

Используйте флаг `-m` с именем маркера. Например:  
```bash
pytest -m smoke
```  
Это запустит только тесты, помеченные декоратором `@pytest.mark.smoke`.

---

# Как отключить вывод пропущенных тестов в Pytest?

Используйте флаг `-rs` с исключением `s` (skipped):  
```bash
pytest -rs -m "not smoke"
```  
Или добавьте в `pytest.ini`:  
```ini
[pytest]
addopts = -rs -m "not smoke"
```  
Это отключит вывод информации о пропущенных тестах.

---

# Какой метод используется для фикстуры, которая выполняется один раз для всех тестов?

Используйте параметр `scope="session"` в фикстуре:  
```python
@pytest.fixture(scope="session")
def shared_resource():
    return setup_resource()
```  
Эта фикстура выполнится один раз и будет доступна для всех тестов в рамках сессии.

---

# Как установить зависимость тестов от фикстуры в Pytest?

Передайте фикстуру как аргумент в тестовую функцию. Например:  
```python
@pytest.fixture
def data():
    return [1, 2, 3]

def test_example(data):
    assert len(data) == 3
```  
Фикстура `data` автоматически выполнится и передаст результат в `test_example`.

---

# Какой аргумент используется для упрощенного вывода сообщений в тестах Pytest?

Используйте флаг `-v` (verbose):  
```bash
pytest -v
```  
Это добавит подробный вывод, включая имена тестов и их статус (passed, failed, skipped).

---

# Что делает опция `--maxfail` в Pytest?

Опция `--maxfail` останавливает выполнение тестов после указанного количества падений. Например:  
```bash
pytest --maxfail=3
```  
Остановит тесты после 3 неудачных результатов.

---

# Какой декоратор используется для параметризации тестов в Pytest?

Используйте декоратор `@pytest.mark.parametrize`. Например:  
```python
@pytest.mark.parametrize("input, expected", [(1, 2), (3, 4)])
def test_increment(input, expected):
    assert input + 1 == expected
```  
Этот тест запустится для каждого набора параметров.

---

# Как запустить тесты и записать отчет в файл?

Используйте флаг `--junitxml` для создания XML-отчёта:  
```bash
pytest --junitxml=report.xml
```  
Или `--html` для HTML-отчёта (с плагином `pytest-html`):  
```bash
pytest --html=report.html
```
---

# Какой декоратор используется для ожидания определенного исключения в тестах?

Используйте `pytest.raises` в качестве контекстного менеджера. Например:  
```python
def test_exception():
    with pytest.raises(ValueError):
        int("не число")
```  
Этот тест пройдёт, если будет вызвано исключение `ValueError`.

---

# Что делает команда `pytest --pdb`?

Команда `pytest --pdb` запускает отладчик `pdb` при возникновении ошибки в тесте. Это позволяет интерактивно исследовать состояние программы в момент падения.

---

# Какой метод используется для создания фикстуры, которая создается заново перед каждым тестом?

В `pytest` для создания фикстуры, которая создается заново перед каждым тестом, используется **декоратор `@pytest.fixture`** с параметром **`scope="function"`** (или без указания `scope`, так как `"function"` является значением по умолчанию).

---

# Как в Pytest отметить тест, который должен быть выполнен в течение определенного времени?


Используйте плагин `pytest-timeout` и декоратор `@pytest.mark.timeout`. Например:  
```python
@pytest.mark.timeout(5)  # Тест должен завершиться за 5 секунд
def test_slow_function():
    time.sleep(10)
```  
Если тест превысит указанное время, он будет прерван.


---

# Какое утверждение верно для метода `assert` в Pytest?

Метод `assert` в Pytest используется для проверки условий. Если условие ложно, тест падает с подробным сообщением об ошибке. Например:  
```python
def test_example():
    assert 1 + 1 == 2
```  
Если условие не выполняется, Pytest выведет информацию о том, что пошло не так.

---

# Как задать порядок выполнения тестов?

Используйте плагин `pytest-order` и декоратор `@pytest.mark.order`. Например:  
```python
@pytest.mark.order(1)
def test_first():
    assert True

@pytest.mark.order(2)
def test_second():
    assert True
```  
Тесты выполнятся в указанном порядке.



# Для бенчмарка (измерения производительности) в Pytest используйте плагин `pytest-benchmark`. Пример:


Для бенчмарка (измерения производительности) в Pytest используйте плагин `pytest-benchmark`. Пример:  
```python
def test_benchmark_example(benchmark):
    result = benchmark(lambda: sum(range(1000)))
    assert result == 499500
```  
Запустите тест:  
```bash
pytest --benchmark-only
```  
Плагин покажет статистику по времени выполнения.

## Для мокинга (подмены объектов)
Для мокинга (подмены объектов) используйте `unittest.mock` или фикстуру `monkeypatch` в Pytest. Пример с `monkeypatch`:  
```python
def test_example(monkeypatch):
    def mock_return():
        return 42

    monkeypatch.setattr("module.function", mock_return)
    assert module.function() == 42
```  
Это временно заменяет `module.function` на `mock_return` только для этого теста.


# как проверить покрые тестами

Используйте плагин `pytest-cov` для проверки покрытия кода тестами. Установите его и запустите:  
```bash
pytest --cov=your_module
```  
Это покажет процент покрытия кода тестами. Для детального отчёта добавьте:  
```bash
pytest --cov=your_module --cov-report=html
```  
Отчёт сохранится в папке `htmlcov`.